{
  "ver": "1.0.25",
  "uuid": "d87586ff-8886-4efb-af4b-27caf1036663",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\nuniform float width;\nuniform float height;\nuniform float offx;\nuniform float offy;\nuniform float rotation;\nvoid main () {\n  mat4 mvp;\n  mvp = cc_matViewProj;\n  v_uv0 = vec2(1.0 - a_uv0.x,a_uv0.y);\n  vec4 tmp_pos = vec4(0.0, 0.0, 0.0, 0.0);\n  tmp_pos = vec4(a_position.x, a_position.y, 0.0, 1.0);\n  if(tmp_pos.x < 0.0 || tmp_pos.x > width || tmp_pos.y < 0.0 || tmp_pos.y > height){\n  tmp_pos.x = 0.0;tmp_pos.y = 0.0;}\n  float cl = height/5.0;\n  float sl = (height - cl)/2.0;\n  float radii = (cl/rotation)/2.0;\n  float sinRot = sin(rotation);\n  float cosRot = cos(rotation);\n  float distance = radii*sinRot;\n  float centerY = height/2.0;\n  float poxY1 = centerY - distance;\n  float poxY2 = centerY + distance;\n  float posZ = sl*sinRot;\n  if(tmp_pos.y <= sl){\n     float length = sl - tmp_pos.y;\n     tmp_pos.y = poxY1 - length*cosRot;\n     tmp_pos.z = posZ - length*sinRot;\n  }\n  else if(tmp_pos.y < (sl+cl)){\n     float el = tmp_pos.y - sl;\n     float rotation2 = -el/radii;\n     float x1 = poxY1;\n     float y1 = posZ;\n     float x2 = centerY;\n     float y2 = posZ - radii*cosRot;\n     float sinRot2 = sin(rotation2);\n     float cosRot2 = cos(rotation2);\n     tmp_pos.y=(x1-x2)*cosRot2-(y1-y2)*sinRot2+x2;\n     tmp_pos.z=(y1-y2)*cosRot2+(x1-x2)*sinRot2+y2;\n  }\n  else if(tmp_pos.y <= height){\n      float length = tmp_pos.y - cl - sl;\n      tmp_pos.y = poxY2 + length*cosRot;\n      tmp_pos.z = posZ - length*sinRot;\n  }\n  if(rotation <= 0.1){\n      tmp_pos = vec4(a_position.x, a_position.y, 0.0, 1.0);\n  }\n  tmp_pos += vec4(offx, offy, 0.0, 0.0);\n  gl_Position = mvp * tmp_pos;\n}",
        "frag": "\nprecision highp float;\nuniform sampler2D textureBack;\nuniform sampler2D textureFront;\nvarying mediump vec2 v_uv0;\n#if USE_ALPHA_TEST\n#endif\nvoid main () {\n  vec4 color = vec4(1.);\n  color *= texture2D(textureFront, v_uv0);\n  gl_FragColor = color;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin mediump vec2 a_uv0;\nout mediump vec2 v_uv0;\nuniform RATIO {\n  float ratio;\n  float radius;\n  float width;\n  float height;\n  float offx;\n  float offy;\n  float rotation;\n};\nvoid main () {\n  mat4 mvp;\n  mvp = cc_matViewProj;\n  v_uv0 = vec2(1.0 - a_uv0.x,a_uv0.y);\n  vec4 tmp_pos = vec4(0.0, 0.0, 0.0, 0.0);\n  tmp_pos = vec4(a_position.x, a_position.y, 0.0, 1.0);\n  if(tmp_pos.x < 0.0 || tmp_pos.x > width || tmp_pos.y < 0.0 || tmp_pos.y > height){\n  tmp_pos.x = 0.0;tmp_pos.y = 0.0;}\n  float cl = height/5.0;\n  float sl = (height - cl)/2.0;\n  float radii = (cl/rotation)/2.0;\n  float sinRot = sin(rotation);\n  float cosRot = cos(rotation);\n  float distance = radii*sinRot;\n  float centerY = height/2.0;\n  float poxY1 = centerY - distance;\n  float poxY2 = centerY + distance;\n  float posZ = sl*sinRot;\n  if(tmp_pos.y <= sl){\n     float length = sl - tmp_pos.y;\n     tmp_pos.y = poxY1 - length*cosRot;\n     tmp_pos.z = posZ - length*sinRot;\n  }\n  else if(tmp_pos.y < (sl+cl)){\n     float el = tmp_pos.y - sl;\n     float rotation2 = -el/radii;\n     float x1 = poxY1;\n     float y1 = posZ;\n     float x2 = centerY;\n     float y2 = posZ - radii*cosRot;\n     float sinRot2 = sin(rotation2);\n     float cosRot2 = cos(rotation2);\n     tmp_pos.y=(x1-x2)*cosRot2-(y1-y2)*sinRot2+x2;\n     tmp_pos.z=(y1-y2)*cosRot2+(x1-x2)*sinRot2+y2;\n  }\n  else if(tmp_pos.y <= height){\n      float length = tmp_pos.y - cl - sl;\n      tmp_pos.y = poxY2 + length*cosRot;\n      tmp_pos.z = posZ - length*sinRot;\n  }\n  if(rotation <= 0.1){\n      tmp_pos = vec4(a_position.x, a_position.y, 0.0, 1.0);\n  }\n  tmp_pos += vec4(offx, offy, 0.0, 0.0);\n  gl_Position = mvp * tmp_pos;\n}",
        "frag": "\nprecision highp float;\nuniform sampler2D textureBack;\nuniform sampler2D textureFront;\nvarying mediump vec2 v_uv0;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid main () {\n  vec4 color = vec4(1.);\n  color *= texture2D(textureFront, v_uv0);\n  gl_FragColor = color;\n}"
      }
    }
  ],
  "subMetas": {}
}